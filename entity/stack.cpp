#include"../include/stack.h"
#include<stdexcept>
#include<iostream>

using namespace std;

// Конструктор узла стека, инициализирует данные и указатель на следующий элемент
StackNode::StackNode(string v) : data(v), next(nullptr) {}

// Конструктор стека, инициализирует вершину как пустой указатель и размер как 0
Stack::Stack() : head(nullptr), sz(0) {}

// Проверка, является ли стек пустым
bool Stack::is_empty() { return head == nullptr; }

// Получение текущего размера стека
size_t Stack::size() { return sz; }

// Добавление элемента в вершину стека
void Stack::push(string value) {
    // Создание нового узла с переданным значением
    StackNode* p = new StackNode(value);
    // Новый узел указывает на текущую вершину стека
    p->next = head;
    // Вершиной стека становится новый узел
    head = p;
    // Увеличение счетчика размера стека
    ++sz;
}

// Удаление элемента из вершины стека
void Stack::pop() {
    // Проверка, что стек не пустой
    if (is_empty()) throw runtime_error("Стек пуст");
    // Сохранение указателя на текущую вершину
    StackNode* p = head;
    // Перемещение вершины на следующий элемент
    head = head->next;
    // Освобождение памяти удаляемого узла
    delete p;
    // Уменьшение счетчика размера стека
    --sz;
}

// Вывод всех элементов стека на экран
void Stack::print() {
    // Начало с вершины стека
    StackNode* p = head;
    // Проход по всем элементам стека до конца
    while (p != nullptr) {
        // Вывод данных текущего элемента
        cout << p->data << " ";
        // Переход к следующему элементу
        p = p->next;
    }
}

// Очистка всего стека
void Stack::clear() {
    // Последовательное удаление всех элементов из стека
    while (!is_empty()) pop();
}

// Деструктор стека - автоматически очищает память при уничтожении объекта
Stack::~Stack() { clear(); }